<html>
<head>

<link type="text/css" rel="stylesheet" href="syntaxhighlighter/styles/shCore.css" />
<link type="text/css" rel="stylesheet" href="syntaxhighlighter/styles/shThemeRDark.css" />
<script type="text/javascript" src="syntaxhighlighter/scripts/shCore.js"></script>
<script type="text/javascript" src="syntaxhighlighter/scripts/shBrushPython.js"></script>
<script type="text/javascript" src="syntaxhighlighter/scripts/shBrushBash.js"></script>
<script type="text/javascript" src="syntaxhighlighter/scripts/shBrushCpp.js"></script>
<script type="text/javascript" src="syntaxhighlighter/scripts/shBrushXml.js"></script>
<script type="text/javascript" src="syntaxhighlighter/scripts/shBrushJava.js"></script>
<script type="text/javascript" src="syntaxhighlighter/scripts/shBrushBash.js"></script>

<script type="text/javascript">
  SyntaxHighlighter.all()
</script> 
<link rel="Stylesheet" type="text/css" href="style.css" />
<title>webskill</title>
<meta http-equiv="Content-Type" content="text/html; charset=cp936" />
</head>
<body>


<h1 id="toc_1"> web开发技巧</h1>

<ul>
<li>
唯一流水号生成
</li>
</ul>

<p>
/** 
</p>
<ul>
<li>
Manages sequences of unique ID's that get stored in the database. Database 
</li>
<li>
support for sequences varies widely; some don't support them at all. So, 
</li>
<li>
we handle unique ID generation with a combination VM/database solution.&lt;p&gt; 
</li>
<li>

</li>
<li>
A special table in the database doles out blocks of unique ID's to each 
</li>
<li>
virtual machine that interacts with Jive. This has the following consequences: 
</li>
<li>
&lt;ul&gt; 
</li>
<li>
 &lt;li&gt;There is no need to go to the database every time we want a new unique 
</li>
<li>
     id. 
</li>
<li>
 &lt;li&gt;Multiple app servers can interact with the same db without consequences 
</li>
<li>
     in terms of id's. 
</li>
<li>
 &lt;li&gt;The order of unique id's may not correspond to creation date 
</li>
<li>
     (as they once did);. 
</li>
<li>
&lt;/ul&gt; 
<br /> */ 
</li>
</ul>

<ul>
<li>
事物
</li>
</ul>

<p>
在企业应用中，事务处理是一个很重要的问题，本文阐述了事务处理的相关概念，分析了数据库级别的事务并发时产生的问题和相对应的隔离级别，最后简单谈谈Hibernate对于事务处理的方法。
1.事务(transaction)
事务被认为是一系列操作的集合，是一个工作单元(unit of work)，事务的处理的结果有两个一个是commit，令一个是roll back,事务有ACID特性(atomicity,consistency,isolation, durability)。atomicity是说明事务处理过程中不能够被打断;consistency是指事务所操作的数据是一个一致性的集合，也就是这些数据对于其他并发进行的事务是隐藏的;isolation是指两个并发进行的事务相互之间是不可见的，也就是互不影响;durability是指事务处理的结果将被持久化。
在分析事务处理时，要将原来的单个sql的commit,rollback和对事务的commit，roolback区分开来，一个事务可能是由多个sql操作所组成的。
</p>

<p>
2.并发事务执行时引起的问题
(1)lost update: A和B事务并发执行，A事务执行update后，提交;B事务在A事务update后，B事务结束前也做了对同样数据的update操作，然后rollback，则两次提交操作都丢失了。
(2)dirty read:A和B事务并发执行，B事务执行update后，A事务select B事务没有提交的数据，B事务roolback，则A事务得到的数据不是数据库中的真实数据。也就是dirty data(和数据库中不一致的数据)
(3)unrepeatable read:A和B事务并发执行，A事务select数据，然后B事务update该数据，A再次select该数据时，发现该数据变化了。(second lost updates:是unrepeatable read的一种特殊情况，即A事务update数据，然后B事务update数据，A事务select发现自己update的数据变了，该问题为什么不划分到第一类问题，是和事务的隔离级别相关的，也就是A的select执行时允许了并发的B的update的执行，隔离级别3能够解决该问题，而隔离级别1不能解决该问题)
(4)phantom read:A和B事务并发执行，A事务select数据，B事务insert或者update数据，A事务再次select发现结果集中有以前没有的数据或者以前有的数据消失了。
</p>

<p>
3.事务的隔离级别
在企业应用中，事务往往存在于并发执行的环境当中，那么如果做到并发事务之间完全的isolation，做到对于以上四大问题完全解决，那么势必会影响程序的performance和scalability,因此减弱这种完全的isolation，而带来的就是performance和scalability的提高。因此事务的隔离级别根据以前的四大问题有四种。
(1)read uncommitted isolation:不允许(1)问题存在，允许(2)问题存在。写事务执行时不允许同时有其他的写事务并发执行。
(2)read committed isolation:不允许(2)问题存在，允许(3)问题存在。读事务允许其他事务并发执行，没有提交的写事务执行时不允许同时有其他并发事务执行。
(3)repeatable read isolation:不允许(3)问题存在，允许(4)问题存在。读事务不允许写事务并发执行，没有提交的写事务执行时不允许同时有其他并发事务执行。
(4)serializable:完全解决问题。
</p>

<p>
4.Hibernate的折衷解决方案
一般的应用作隔离级别时，往往采用(2),(3)两种，(1),(4)两种前者轻后者重，但是Hibernate为了提高performance和scalability，在数据库一层中采用的是(2)的隔离级别，然后在程序中进行控制，从而实现了(3)的隔离级别，因此提高了企业应用的事务处理效率。当然Hibernate对于数据库一层的隔离级别也可以显示指定。
Hibernate在程序中的控制方法有:version number, timestamp,对于遗留database也有optimistic-lock，而version number有时不能解决特殊的事务并发引起来的(3)问题，那么就需要针对特殊情况进行细粒度的事务控制，可以看一下LOCKMODE。
先写这些，如果大家感兴趣，我可以再把Hibernate具体的解决方案总结归纳。
</p>


<ul>
<li>
无锁
</li>
</ul>

<p>
库存表带个timestamp，进调拨画面把当时的timestamp带过来，保存，提交时update语句带where timestamp = 当时的值。
依靠DB自身的update屏蔽并发冲突，省心省力，不用额外的lock 
</p>


<ul>
<li>
异步
</li>
</ul>

<ul>
<li>
NIO与长连接
</li>
</ul>


<ul>
<li>
tomcat中建立独立线程
</li>
</ul>

<p>
似乎应该开独立进程处理这事
</p>

</body>
</html>
